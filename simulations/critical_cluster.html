<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>simulation</title>
    <link rel="stylesheet" href="../style.css">
</head>

<body>
    <div class="container">
        <a href="../index.html" class="btn">back</a>
        <h2 style="color: #272727; margin-bottom: 10px;">Critical Percolation Cluster Growth</h2>

        <canvas id="percolation-canvas" width="600" height="600"></canvas>

        <div class="controls">
            <button class="btn" onclick="startSimulation()">Start</button>
            <button class="btn" onclick="pauseSimulation()">Pause</button>
            <button class="btn" onclick="resetSimulation()">Reset</button>
            <span style="margin-left: 20px;">p = <span id="prob-display">0.5</span></span>
        </div>

        <div class="info">
            Generation: <span id="generation">0</span> |
            Cluster Size: <span id="cluster-size">0</span>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('percolation-canvas');

        canvas.style.width = '600px';
        canvas.style.height = '600px';

        const ctx = setupHighDPICanvas(canvas);

        const gridSize = 400;
        const displaySize = 600;
        const cellSize = displaySize / gridSize;
        const center = Math.floor(gridSize / 2);

        const p_c = 0.5;

        let grid = [];
        let frontier = [];
        let generation = 0;
        let clusterSize = 0;
        let animationId = null;
        let isRunning = false;

        function initGrid() {
            grid = Array(gridSize).fill().map(() => Array(gridSize).fill(-1));
            frontier = [{ x: center, y: center, gen: 0 }];
            generation = 0;
            clusterSize = 0;

            grid[center][center] = 0;
            clusterSize = 1;

            updateDisplay();
        }

        function generationToColor(gen, maxGen) {
            if (gen === -1) return '#eaeaea';

            const normalizedGen = gen / Math.max(maxGen, 1);
            const hue = (1 - normalizedGen) * 270;
            const saturation = 85;
            const lightness = 60;

            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        function initPercolationCanvas() {
            const canvas = document.getElementById('percolation-canvas');

            // Set CSS size (what user sees)
            canvas.style.width = '600px';
            canvas.style.height = '600px';

            // Setup high DPI
            const ctx = setupHighDPICanvas(canvas);

            // Your grid parameters (these stay the same logically)
            const gridSize = 400;
            const displaySize = 600; // CSS pixels
            const cellSize = displaySize / gridSize; // Now in CSS pixels

            return { ctx, cellSize, gridSize };
        }

        function setupHighDPICanvas(canvas) {
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();

            const dpr = window.devicePixelRatio || 1;

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';

            ctx.scale(dpr, dpr);
            ctx.imageSmoothingEnabled = false;

            return ctx;
        }

        function drawGrid() {
            ctx.clearRect(0, 0, 600, 600);
            const maxGen = Math.max(...grid.flat().filter(x => x >= 0));

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const color = generationToColor(grid[i][j], maxGen);
                    ctx.fillStyle = color;
                    ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);

                    if (grid[i][j] >= 0) {
                        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                        ctx.lineWidth = 0.5;
                        ctx.strokeRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    }
                }
            }
        }



        function getNeighbors(x, y) {
            const neighbors = [];
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];

            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                    neighbors.push({ x: nx, y: ny });
                }
            }
            return neighbors;
        }

        function simulationStep() {
            if (frontier.length === 0) {
                pauseSimulation();
                return;
            }

            const newFrontier = [];

            for (let cell of frontier) {
                const neighbors = getNeighbors(cell.x, cell.y);

                for (let neighbor of neighbors) {
                    const { x, y } = neighbor;

                    if (grid[x][y] >= 0) continue;

                    if (Math.random() < p_c) {
                        grid[x][y] = cell.gen + 1;
                        newFrontier.push({ x, y, gen: cell.gen + 1 });
                        clusterSize++;
                    }
                }
            }

            frontier = newFrontier;
            if (newFrontier.length > 0) {
                generation++;
            }

            drawGrid();
            updateDisplay();
        }

        function updateDisplay() {
            document.getElementById('generation').textContent = generation;
            document.getElementById('cluster-size').textContent = clusterSize;
            document.getElementById('prob-display').textContent = p_c.toFixed(3);
        }

        function animate() {
            if (isRunning) {
                simulationStep();
                animationId = setTimeout(animate, 10);
            }
        }

        window.startSimulation = function () {
            if (!isRunning) {
                isRunning = true;
                animate();
            }
        };

        window.pauseSimulation = function () {
            isRunning = false;
            if (animationId) {
                clearTimeout(animationId);
            }
        };

        window.resetSimulation = function () {
            pauseSimulation();
            initGrid();
            drawGrid();
        };

        initGrid();
        drawGrid();
    </script>
</body>

</html>